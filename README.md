{
  "readme_content": "# soni_hp: Cross-Chain Bridge Event Listener Simulation\n\nThis repository contains a Python-based simulation of a critical component in a decentralized cross-chain bridge: the **Event Listener**. This script simulates a service that monitors a bridge contract on a source blockchain, processes its events, and simulates the corresponding actions required on a destination chain.\n\n## Key Features\n\n-   **Modular Design**: A clear separation of concerns among distinct classes (`BlockchainConnector`, `EventProcessor`, `StateManager`) makes the system easy to maintain and test.\n-   **Reorg Protection**: Waits for a configurable number of block confirmations before processing events, mitigating the risk of chain reorganizations.\n-   **State Management**: Prevents the double-processing of events (replay attacks) by using a persistent state manager.\n-   **Extensibility**: Easily adaptable for different contracts, events, or chains by modifying the configuration.\n-   **Robust Logging**: Provides detailed, informative logs for monitoring the listener's status and debugging issues.\n\n## Concept\n\nA cross-chain bridge allows users to transfer assets or data from one blockchain (e.g., Ethereum) to another (e.g., Polygon). A common mechanism is the \"lock-and-mint\" model:\n\n1.  **Lock**: A user deposits an asset (e.g., `USDC`) into a smart contract on the source chain.\n2.  **Event Emission**: The smart contract locks the asset and emits an event (e.g., `TokensLocked`) containing details of the transaction (sender, recipient, amount, destination chain).\n3.  **Listen**: Off-chain services, called listeners or relayers, constantly monitor the source chain for these specific events.\n4.  **Validate & Relay**: Upon detecting a confirmed `TokensLocked` event, the listener validates it and relays the information to the destination chain.\n5.  **Mint**: A corresponding smart contract on the destination chain receives this information and mints an equivalent amount of a wrapped token (e.g., `pUSDC`) for the recipient.\n\nThis script simulates the crucial **Steps 3 and 4**, acting as the off-chain listener that ensures the bridge functions correctly and securely.\n\n## Code Architecture\n\nThe system's architecture is divided into the following core classes, each with a specific responsibility:\n\n-   `CrossChainBridgeEventListener`\n    -   **Role**: The main orchestrator. It manages the application loop, coordinates all other components, and handles the high-level logic of polling for events.\n\n-   `BlockchainConnector`\n    -   **Role**: A wrapper for the `web3.py` library that abstracts all direct blockchain interactions. It handles connecting to an RPC node, fetching blocks, creating contract instances, and querying for event logs.\n\n-   `EventProcessor`\n    -   **Role**: Responsible for the business logic of handling a raw event. It parses the event data, validates its integrity, and can enrich it with additional information. In this simulation, it fetches a token's price via a `requests` call to the CoinGecko API.\n    ```python\n    # A conceptual look at the EventProcessor's main method\n    class EventProcessor:\n        # ... other methods like __init__ ...\n\n        def process_event(self, raw_event):\n            \"\"\"Parses, validates, and enriches a raw blockchain event.\"\"\"\n            event_args = raw_event['args']\n            \n            # 1. & 2. Parse and Validate\n            processed_event = {\n                'tx_hash': raw_event['transactionHash'].hex(),\n                'log_index': raw_event['logIndex'],\n                'sender': event_args.get('sender'),\n                # ... other fields\n            }\n\n            # 3. Enrich data\n            token_price = self._fetch_token_price(event_args.get('token'))\n            processed_event['token_price_usd'] = token_price\n\n            # 4. Return structured data\n            return processed_event\n\n        def _fetch_token_price(self, token_address):\n            # ... implementation for CoinGecko API call ...\n            pass\n    ```\n\n-   `StateManager`\n    -   **Role**: Prevents the double-processing of events (replay attacks). It keeps track of the transaction hashes and log indices of events that have already been successfully processed. In this simulation, it's an in-memory set, but in a production system, it would be backed by a persistent database like Redis or PostgreSQL.\n\n-   **Custom Exceptions**\n    -   `RPCConnectionError`, `EventProcessingError`, `InvalidEventError`: These provide more specific error handling than generic exceptions, making the system's behavior easier to debug and understand.\n\n### Architectural Flow\n\n```\n+---------------------------------+\n| CrossChainBridgeEventListener   | (Orchestrator)\n| - run()                         |\n+----------------|----------------+\n                 | Polls every N seconds\n                 v\n+----------------|----------------+\n| BlockchainConnector (Source)    |\n| - get_latest_block_number()     |\n| - get_events()                  |\n+----------------|----------------+\n                 | Returns raw events\n                 v\n+----------------|----------------+\n| EventProcessor                  |\n| - process_event()               |<>---+ (Uses to check for duplicates)\n|  - Parse                        |\n|  - Validate                     |    | +--------------+\n|  - Enrich (e.g., API call)      |    +-->| StateManager |\n+----------------|----------------+      +--------------+\n                 | Returns processed data\n                 v\n+---------------------------------+\n| CrossChainBridgeEventListener   |\n| - simulate_destination_action() |\n| - Updates StateManager          |\n+---------------------------------+\n```\n\n## How It Works\n\nThe listener operates in a continuous loop with the following steps:\n\n1.  **Initialization**: The main `CrossChainBridgeEventListener` is instantiated. It creates instances of the blockchain connectors, state manager, and event processor.\n\n2.  **Polling Block Range**: The script calculates a block range to scan. It starts from the last block it successfully processed and scans up to the latest block minus a `BLOCK_CONFIRMATIONS` buffer. This buffer is critical for mitigating the risk of processing events from blocks that might be reversed due to a chain reorganization (reorg).\n\n3.  **Event Fetching**: Using the `BlockchainConnector`, it queries the source chain's bridge contract for any `TokensLocked` events within the calculated block range.\n\n4.  **Processing**: For each event found, it is passed to the `EventProcessor` and undergoes the following steps:\n    a.  **Replay Protection**: The `StateManager` is first checked to see if the event's unique identifier (a combination of transaction hash and log index) has been processed before. If so, it's ignored.\n    b.  **Parsing & Validation**: The event's arguments (sender, amount, etc.) are extracted and checked for completeness.\n    c.  **Data Enrichment**: An external API call is made to fetch the USD price of the transferred token, demonstrating how off-chain data can be integrated.\n\n5.  **Action Simulation**: For each valid, new event, the script calls `simulate_destination_chain_action()`. This method logs a detailed message describing the transaction that *would* be created and sent to the destination chain to mint the new tokens.\n\n6.  **State Update**: Once an event has been successfully processed and its corresponding action simulated, its identifier is saved in the `StateManager` to prevent it from being processed again.\n\n7.  **Loop**: The script waits for a configurable `POLL_INTERVAL_SECONDS` and then repeats the process, ensuring continuous and up-to-date monitoring of the bridge.\n\n## Prerequisites\n\n- Python 3.8+\n- pip\n\n## Usage\n\n### 1. Set Up the Environment\n\nTo get started, clone the repository and set up your local environment:\n\n```bash\ngit clone https://github.com/your-github-username/soni_hp.git\ncd soni_hp\n```\n\nCreate a Python virtual environment and activate it:\n\n```bash\npython3 -m venv venv\nsource venv/bin/activate\n```\n\nInstall the required dependencies:\n\n```bash\npip install -r requirements.txt\n```\n\n### 2. Configuration\n\nCreate a file named `.env` in the project root. The listener loads its configuration from this file on startup. It should contain your RPC URLs and any other secrets:\n\n```dotenv\n# .env file\nSOURCE_CHAIN_RPC=\"https://your-sepolia-rpc-url.com\"\nDESTINATION_CHAIN_RPC=\"https://your-polygon-rpc-url.com\"\n```\n\n> **Note**: The script contains public, placeholder RPC URLs. These public URLs may be rate-limited or unreliable. For production or extensive testing, it is highly recommended to use your own private RPC endpoints from a service like Infura or Alchemy.\n\n### 3. Run the Listener\n\nThe main entry point is `script.py`. It loads the configuration from your `.env` file, initializes the `CrossChainBridgeEventListener`, and starts the monitoring loop.\n\nHere is the main execution block in `script.py`:\n\n```python\n# script.py\nimport logging\nfrom event_listener import CrossChainBridgeEventListener\nfrom config import (\n    SOURCE_CHAIN_RPC,\n    DESTINATION_CHAIN_RPC,\n    BRIDGE_CONTRACT_ADDRESS,\n    POLL_INTERVAL_SECONDS,\n)\n\nlogging.basicConfig(level=logging.INFO, format='%(asctime)s - [%(levelname)s] - %(message)s')\n\nif __name__ == \"__main__\":\n    try:\n        listener = CrossChainBridgeEventListener(\n            source_rpc_url=SOURCE_CHAIN_RPC,\n            dest_rpc_url=DESTINATION_CHAIN_RPC,\n            bridge_contract_address=BRIDGE_CONTRACT_ADDRESS,\n            poll_interval=POLL_INTERVAL_SECONDS,\n        )\n        listener.run()\n    except KeyboardInterrupt:\n        logging.info(\"Listener stopped by user.\")\n    except Exception as e:\n        logging.error(f\"An unexpected error occurred: {e}\", exc_info=True)\n```\n\nTo start the listener, execute the script from your terminal:\n\n```bash\npython script.py\n```\n\n### 4. Sample Output\n\nThe script will start logging its activity to the console. You will see messages indicating its status, any events it finds, and the simulated actions.\n\n```\n2023-10-27 10:30:01 - [INFO] - *** Cross-Chain Bridge Event Listener starting... ***\n2023-10-27 10:30:01 - [INFO] - Listening for 'TokensLocked' events on contract: 0x7B3...aF42\n2023-10-27 10:30:02 - [INFO] - Successfully connected to source chain RPC: https://rpc.sepolia.org\n2023-10-27 10:30:03 - [INFO] - Successfully connected to destination chain RPC: https://rpc-mumbai.maticvigil.com/\n2023-10-27 10:30:03 - [INFO] - StateManager initialized (in-memory).\n2023-10-27 10:30:03 - [INFO] - EventProcessor initialized.\n2023-10-27 10:30:05 - [INFO] - Scanning for 'TokensLocked' events from block 4812300 to 4812315...\n2023-10-27 10:30:06 - [DEBUG] - No new events found in this range.\n2023-10-27 10:30:20 - [INFO] - Scanning for 'TokensLocked' events from block 4812316 to 4812317...\n2023-10-27 10:30:21 - [INFO] - Found 1 new raw event(s). Processing...\n2023-10-27 10:30:22 - [INFO] - Successfully processed event from tx 0x123abc...def456 (Log Index: 101)\n2023-10-27 10:30:22 - [INFO] - --- SIMULATING DESTINATION CHAIN ACTION ---\n2023-10-27 10:30:22 - [INFO] -   Action: Mint tokens for recipient 0xRecipientAddress...\n2023-10-27 10:30:22 - [INFO] -   Amount: 1000000000000000000 of token 0xTokenAddress...\n2023-10-27 10:30:22 - [INFO] -   Source Tx: 0x123abc...def456\n2023-10-27 10:30:22 - [INFO] -   Nonce: 101\n2023-10-27 10:30:22 - [INFO] -   Status: Action would be sent to the destination chain relayer network.\n2023-10-27 10:30:22 - [INFO] - -------------------------------------------\n...\n```"
}