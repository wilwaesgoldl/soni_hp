{
  "readme_content": "# soni_hp: Cross-Chain Bridge Event Listener Simulation\n\nThis repository contains a Python-based simulation of a critical component in a decentralized cross-chain bridge: the **Event Listener**. This script provides a robust, well-architected service that monitors a bridge contract on a source blockchain, processes events, and simulates corresponding actions on a destination chain.\n\n## Key Features\n\n-   **Modular Design**: Clear separation of concerns into distinct classes (`BlockchainConnector`, `EventProcessor`, `StateManager`) for easy maintenance and testing.\n-   **Reorg Protection**: Intelligently waits for a configurable number of block confirmations before processing events, mitigating the risk of chain reorganizations.\n-   **State Management**: Includes a state manager to prevent the double-processing of events (replay attack protection).\n-   **Extensibility**: Easily adaptable to monitor different contracts, events, or chains by modifying the configuration.\n-   **Clear Logging**: Provides detailed, informative logs for monitoring the listener's status and debugging issues.\n\n## Concept\n\nA cross-chain bridge allows users to transfer assets or data from one blockchain (e.g., Ethereum) to another (e.g., Polygon). A common mechanism is the \"lock-and-mint\" model:\n\n1.  **Lock**: A user deposits an asset (e.g., `USDC`) into a smart contract on the source chain.\n2.  **Event Emission**: The smart contract locks the asset and emits an event (e.g., `TokensLocked`) containing details of the transaction (sender, recipient, amount, destination chain).\n3.  **Listen**: Off-chain services, called listeners or relayers, constantly monitor the source chain for these specific events.\n4.  **Validate & Relay**: Upon detecting a confirmed `TokensLocked` event, the listener validates it and relays the information to the destination chain.\n5.  **Mint**: A corresponding smart contract on the destination chain receives this information and mints an equivalent amount of a wrapped token (e.g., `pUSDC`) for the recipient.\n\nThis script simulates the crucial **Steps 3 and 4**, acting as the off-chain listener that ensures the bridge functions correctly and securely.\n\n## Code Architecture\n\nThe script is designed with a clear separation of concerns, using distinct classes to handle different aspects of the process. This makes the system more modular, testable, and maintainable.\n\n-   `CrossChainBridgeEventListener`\n    -   **Role**: The main orchestrator. It manages the application loop, coordinates all other components, and handles the high-level logic of polling for events.\n\n-   `BlockchainConnector`\n    -   **Role**: A wrapper around the `web3.py` library. It abstracts all direct blockchain interactions, such as connecting to an RPC node, fetching blocks, creating contract instances, and querying for event logs. The listener instantiates two connectors: one for the source chain and one for the destination chain.\n\n-   `EventProcessor`\n    -   **Role**: Responsible for the business logic of handling a raw event. It parses the event data, validates its integrity, and can enrich it with off-chain information (in this simulation, it fetches a token's price via a `requests` call to the CoinGecko API).\n    ```python\n    # A conceptual look at the EventProcessor's main method\n    def process_event(raw_event):\n        # 1. Parse data from raw_event['args']\n        # 2. Validate data (e.g., check for required fields)\n        # 3. Enrich data (e.g., call CoinGecko API for token price)\n        # 4. Return structured, processed event data\n        return processed_event\n    ```\n\n-   `StateManager`\n    -   **Role**: Prevents the double-processing of events (replay attacks). It keeps track of the transaction hashes of events that have already been successfully processed. In this simulation, it's an in-memory set, but in a production system, it would be backed by a persistent database like Redis or PostgreSQL.\n\n-   **Custom Exceptions**\n    -   `RPCConnectionError`, `EventProcessingError`, `InvalidEventError`: These provide more specific error handling than generic exceptions, making the system's behavior easier to debug and understand.\n\n### Architectural Flow\n\n```\n+---------------------------------+\n| CrossChainBridgeEventListener   | (Orchestrator)\n| - run()                         |\n+----------------|----------------+\n                 | Polls every N seconds\n                 v\n+----------------|----------------+\n| BlockchainConnector (Source)    |\n| - get_latest_block_number()     |\n| - get_events()                  |\n+----------------|----------------+\n                 | Returns raw events\n                 v\n+----------------|----------------+\n| EventProcessor                  |\n| - process_event()               |<>---+ (Uses to check for duplicates)\n|  - Parse                        |    |\n|  - Validate                     |    | +--------------+\n|  - Enrich (e.g., API call)      |    +-->| StateManager |\n+----------------|----------------+      +--------------+\n                 | Returns processed data\n                 v\n+---------------------------------+\n| CrossChainBridgeEventListener   |\n| - simulate_destination_action() |\n| - Updates StateManager          |\n+---------------------------------+\n```\n\n## How It Works\n\nThe listener operates in a continuous loop with the following steps:\n\n1.  **Initialization**: The main `CrossChainBridgeEventListener` is instantiated. It creates instances of the blockchain connectors, state manager, and event processor.\n\n2.  **Polling Block Range**: The script doesn't just ask for the latest events. It intelligently calculates a block range to scan. It starts from the last block it successfully processed and scans up to the latest block minus a `BLOCK_CONFIRMATIONS` buffer. This buffer is critical to mitigate the risk of processing events from blocks that might be reversed due to a chain reorganization (reorg).\n\n3.  **Event Fetching**: Using the `BlockchainConnector`, it queries the source chain's bridge contract for any `TokensLocked` events within the calculated block range.\n\n4.  **Processing**: If events are found, they are passed one-by-one to the `EventProcessor`:\n    a.  **Replay Protection**: The `StateManager` is first checked to see if the event's unique identifier (a combination of transaction hash and log index) has been processed before. If so, it's ignored.\n    b.  **Parsing & Validation**: The event's arguments (sender, amount, etc.) are extracted and checked for completeness.\n    c.  **Data Enrichment**: An external API call is made to fetch the USD price of the transferred token, demonstrating how off-chain data can be integrated.\n\n5.  **Action Simulation**: For each valid, new event, the script calls `simulate_destination_chain_action()`. This method logs a detailed message describing the transaction that *would* be created and sent to the destination chain to mint the new tokens.\n\n6.  **State Update**: Once an event has been successfully processed and its corresponding action simulated, its identifier is saved in the `StateManager` to prevent it from being processed again.\n\n7.  **Loop**: The script waits for a configurable `POLL_INTERVAL_SECONDS` and then repeats the process, ensuring continuous and up-to-date monitoring of the bridge.\n\n## Usage\n\n### 1. Setup the Environment\n\nFirst, clone the repository and navigate into the directory:\n\n```bash\ngit clone https://github.com/your-username/soni_hp.git\ncd soni_hp\n```\n\nCreate a Python virtual environment and activate it:\n\n```bash\npython3 -m venv venv\nsource venv/bin/activate\n```\n\nInstall the required dependencies:\n\n```bash\npip install -r requirements.txt\n```\n\n### 2. Configuration\n\nCreate a `.env` file in the project root to store your RPC URLs and other secrets. The script is configured to load these environment variables on startup.\n\nCreate a file named `.env` in the root directory:\n\n```dotenv\n# .env file\nSOURCE_CHAIN_RPC=\"https://your-sepolia-rpc-url.com\"\nDESTINATION_CHAIN_RPC=\"https://your-polygon-rpc-url.com\"\n```\n\n> **Note**: The script contains public, placeholder RPC URLs. These public URLs may be rate-limited or unreliable. For production or extensive testing, it's highly recommended to use your own private RPC endpoints from a service like Infura or Alchemy.\n\n### 3. Run the Listener\n\nThe script's main entry point is `script.py`. It initializes and runs the listener, pulling its configuration from the environment variables set in your `.env` file.\n\nTo start the listener, execute the script from your terminal:\n\n```bash\npython script.py\n```\n\nThe core logic in `script.py` that launches the service is straightforward:\n\n```python\n# A simplified look at the main execution block in script.py\nfrom event_listener import CrossChainBridgeEventListener\nfrom config import (\n    SOURCE_CHAIN_RPC,\n    DESTINATION_CHAIN_RPC,\n    BRIDGE_CONTRACT_ADDRESS,\n    POLL_INTERVAL_SECONDS\n)\n\nif __name__ == \"__main__\":\n    listener = CrossChainBridgeEventListener(\n        source_rpc_url=SOURCE_CHAIN_RPC,\n        dest_rpc_url=DESTINATION_CHAIN_RPC,\n        bridge_contract_address=BRIDGE_CONTRACT_ADDRESS,\n        poll_interval=POLL_INTERVAL_SECONDS,\n    )\n    listener.run()\n\n```\n\n### 4. Sample Output\n\nThe script will start logging its activity to the console. You will see messages indicating its status, any events it finds, and the simulated actions.\n\n```\n2023-10-27 15:30:00 - [INFO] - *** Cross-Chain Bridge Event Listener starting... ***\n2023-10-27 15:30:00 - [INFO] - Listening for 'TokensLocked' on contract: 0xAb5801a7D398351b8bE11C439e05C5B3259aeC9B\n2023-10-27 15:30:02 - [INFO] - Successfully connected to RPC endpoint: https://rpc.sepolia.org\n2023-10-27 15:30:03 - [INFO] - Successfully connected to RPC endpoint: https://rpc-mumbai.maticvigil.com/\n2023-10-27 15:30:03 - [INFO] - StateManager initialized (in-memory).\n2023-10-27 15:30:03 - [INFO] - EventProcessor initialized.\n2023-10-27 15:30:05 - [INFO] - Scanning for 'TokensLocked' events from block 4812300 to 4812315...\n2023-10-27 15:30:06 - [DEBUG] - No new events found in this range.\n2023-10-27 15:30:16 - [INFO] - Scanning for 'TokensLocked' events from block 4812316 to 4812317...\n2023-10-27 15:30:18 - [INFO] - Found 1 new raw event(s). Processing...\n2023-10-27 15:30:19 - [INFO] - Successfully processed event from tx 0x123abcde... nonce 101\n2023-10-27 15:30:19 - [INFO] - --- SIMULATING DESTINATION CHAIN ACTION ---\n2023-10-27 15:30:19 - [INFO] -   Action: Mint tokens for recipient 0xRecipientAddress...\n2023-10-27 15:30:19 - [INFO] -   Amount: 1000000000000000000 of token 0xTokenAddress...\n2023-10-27 15:30:19 - [INFO] -   Source Tx: 0x123abcde...fgh456\n2023-10-27 15:30:19 - [INFO] -   Nonce: 101\n2023-10-27 15:30:19 - [INFO] -   Status: Action would be sent to the destination chain relayer network.\n2023-10-27 15:30:19 - [INFO] - -------------------------------------------\n...\n```"
}